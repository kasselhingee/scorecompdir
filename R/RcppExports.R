# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @description A lightweight test of a manifold object.
#' Its main benefit is to force compilation of templated functions for the manifold,
#' and to print results to standard output.
#' @param pman An XPtr to a manifold object. Created by `pmanifold()`
#' @return An integer. 0 if the testable parts pass.
NULL

#' @description Apply the `toM` function of a manifold object.
#' @param pman An XPtr to a manifold object. Created by `pmanifold()`.
#' @param u A vector to be transformed to the manifold via `toM`.
#' @return A vector on the manifold.
NULL

#' @param xbetain a concatenated vector of sqrt(x) and beta
#' @param n The dimension of x.
#' @param manifoldname The name of the manifold to transform to
#' @param weightname The name of the weight function to use
#' @param acut The constraint a_c in the weight function
#' @return An RCpp::XPtr object pointing to the ADFun
NULL

#' @param p dimension of measurements
#' @param bd dimension of the parameter vector
#' @param llname name of the likelihood function
#' @return An RCpp::XPtr object pointing to the ADFun
NULL

#' @description Convert an ADFun so that the independent values become dynamic parameters
#' and the dynamic parameters become independent values
#' @param newvalue The value (in the sense after the switch has occured) at which to tape the ADFun
#' @param newdynparam The value of the now dynamic parameters at which to tape the ADFun
#' @return A pointer to an ADFun
NULL

#' @param pfun Rcpp::XPtr to an ADFun with dynamic parameters
#' @param u A vector in the simplex.
#' @param beta a vector of the dynamic parameters
#' @return The Jacobian of pfun
NULL

#' @param pfun Rcpp::XPtr to an ADFun with dynamic parameters
#' @param u A vector in the simplex.
#' @param beta a vector of the dynamic parameters
#' @return The Hessian of pfun
NULL

#' @param pfun Rcpp::XPtr to an ADFun tape a tape with dynamic parameters and independent parameters
#' @param value A vector in the domain of the taped function.
#' @param thetacentre A vector in the space of the dynamic parameters of the recorded function
#' this vector forms the centre of the Taylor approximation
#' @param theta a vector of the dynamic parameters
#' @param order The order of Taylor expansion to use.
#' @description Taylor expansion in the `theta` dimensions, to approximate the gradient wrt the `value` dimensions.
#' @return The approximate value of the gradient, with respect to theta, of pfun
NULL

#' @param pfun Rcpp::XPtr to an ADFun tape a tape with dynamic parameters and independent parameters
#' @param value A vector in the domain of the taped function.
#' @param thetacentre A vector in the space of the dynamic parameters of the recorded function
#' this vector forms the centre of the Taylor approximation
#' @param theta a vector of the dynamic parameters
#' @param order The order of Taylor expansion to use.
#' @description Taylor expansion in the `theta` dimensions, to approximate the gradient wrt the `value` dimensions.
#' @return The approximate value of the gradient, with respect to theta, of pfun
NULL

#' @title Indicate Constant Components of Range
#' @description Use `CppAD`'s `Parameter()` function for `ADFun` objects to see if the returned values of a tape are constant with respect to the `x` arguments.
#' @param pfun A CppAD tape.
#' @param dynparam A set of dynamic parameters for `pfun`.
#' @return A vector logical values. `TRUE` indicates that element of the tape result is constant.
#' @details The `CppAD` function `Parameter(i)` [https://coin-or.github.io/CppAD/doc/fun_property.htm] returns `TRUE` when the `i`th component of the range does not depend on the value of the `x` argument
#' (the `i`th component may still depend on the value of the dynamic parameters (see 'Dynamic' in [https://coin-or.github.io/CppAD/doc/glossary.htm#Parameter]) ).
NULL

#' @title Generate manifold with transformation object
#' @param manifoldname The name of the manifold to transform to. Either 'sphere' or 'simplex'
#' @return An RCpp::XPtr object pointing to the C++ manifold object
#' @details
#'  + "sphere" for square-root transformation from the simplex to the positive orthant of the sphere
#'  + "simplex" for the simplex without any transformation.
#'  + "Ralr" for the additive log-ratio transformation from the simplex to Euclidean space, using the final component of vectors in the denominator of the ratio.
#'  + "Snative" for the sphere without any transformation
#' @export
pmanifold <- function(manifoldname) {
    .Call('_scorecompdir_pmanifold', PACKAGE = 'scorecompdir', manifoldname)
}

testmanifold <- function(pman, u_ad) {
    .Call('_scorecompdir_testmanifold', PACKAGE = 'scorecompdir', pman, u_ad)
}

ptoM <- function(pman, u_ad) {
    .Call('_scorecompdir_ptoM', PACKAGE = 'scorecompdir', pman, u_ad)
}

ptapesmo <- function(u_ad, theta_ad, pll, pman, weightname, acut, verbose) {
    .Call('_scorecompdir_ptapesmo', PACKAGE = 'scorecompdir', u_ad, theta_ad, pll, pman, weightname, acut, verbose)
}

ptapell <- function(z_ad, theta_ad, llname, pman, fixedtheta, verbose) {
    .Call('_scorecompdir_ptapell', PACKAGE = 'scorecompdir', z_ad, theta_ad, llname, pman, fixedtheta, verbose)
}

swapDynamic <- function(pfun, newvalue, newdynparam) {
    .Call('_scorecompdir_swapDynamic', PACKAGE = 'scorecompdir', pfun, newvalue, newdynparam)
}

pJacobian <- function(pfun, value, theta) {
    .Call('_scorecompdir_pJacobian', PACKAGE = 'scorecompdir', pfun, value, theta)
}

#' @title Evaluate a CppAD tape
#' @param pfun Rcpp::XPtr to an ADFun with dynamic parameters
#' @param x A vector in the domain of the taped function.
#' @param dynparam a vector of the dynamic parameters
#' @return The value of `pfun` evaluated at `x` with parameters `dynparam`.
#' @export
pForward0 <- function(pfun, x, dynparam) {
    .Call('_scorecompdir_pForward0', PACKAGE = 'scorecompdir', pfun, x, dynparam)
}

pHessian <- function(pfun, value, theta) {
    .Call('_scorecompdir_pHessian', PACKAGE = 'scorecompdir', pfun, value, theta)
}

#' @title The value of a recorded function approximated by Taylor expansion
#' @param pfun Rcpp::XPtr to an ADFun tape a tape with independent values that are the points to be differentiated with
#' @param u A vector in the domain of the taped function.
#' @param centre A vector in the domain of the taped function to approximate the value at `u` from.
#' @param dynparam a vector of the dynamic parameters
#' @param order The order of Taylor expansion to use.
#' @description Approximates the value of a `CppAD` tape at `u` using a Taylor approximation at `centre`. The dynamic parameters of the tape are set by `dynparam`.
#' @return The approximate value of pfun
#' @export
pTaylorApprox <- function(pfun, u, centre, dynparam, order) {
    .Call('_scorecompdir_pTaylorApprox', PACKAGE = 'scorecompdir', pfun, u, centre, dynparam, order)
}

pTapeJacobianSwap <- function(pfun, value, theta) {
    .Call('_scorecompdir_pTapeJacobianSwap', PACKAGE = 'scorecompdir', pfun, value, theta)
}

pTapeHessianSwap <- function(pfun, value, theta) {
    .Call('_scorecompdir_pTapeHessianSwap', PACKAGE = 'scorecompdir', pfun, value, theta)
}

#' @title Tape the Jacobian of CppAD Tape
#' @param pfun Rcpp::XPtr to an ADFun tape a tape with dynamic parameters and independent parameters
#' @param x A vector in the domain of the taped function.
#' @param dynparam a vector of the dynamic parameters
#' @description Creates a tape of the Jacobian of function taped by CppAD.
#' When the function returns a real value (as is the case for densities and the score matching objective) the Jacobian is equivalent to the gradient.
#' The `x` vector is used as the value to conduct the taping.
#' @details
#' When the returned tape is evaluated (via say [`pForward0()`], the resultant vector contains the Jacobian in long format (see [https://coin-or.github.io/CppAD/doc/jacobian.htm]).
#' Suppose the function represented by `pfun` maps from \eqn{n}-dimensional space to \eqn{m}-dimensional space, then
#' the first \eqn{n} elements of vector is the gradient of the first component of function output.
#' The next \eqn{n} elements of the vector is the gradient of the second component of the function output.
#' The Jacobian as a matrix, could then be obtained by [`as.matrix()`] with `byrow = TRUE` and `ncol = n`.
#' @return A `Rcpp::XPtr` to a CppAD::ADFun object.
#' @export
pTapeJacobian <- function(pfun, x, dynparam) {
    .Call('_scorecompdir_pTapeJacobian', PACKAGE = 'scorecompdir', pfun, x, dynparam)
}

#' @title Tape the Hessian of a CppAD Tape
#' @inheritParams pTapeJacobian
#' @description Creates a tape of the Hessian of a function taped by CppAD.
#' The taped function represented by `pfun` must be scalar-valued (i.e. a vector of length 1).
#' The `x` vector and `dynparam` are used as the values to conduct the taping.
#' @details
#' When the returned tape is evaluated (via say [`pForward0()`], the resultant vector contains the Hessian in long format (see [https://coin-or.github.io/CppAD/doc/hessian.htm]).
#' Suppose the function represented by `pfun` maps from \eqn{n}-dimensional space to \eqn{1}-dimensional space, then
#' the first \eqn{n} elements of the vector is the gradient of the partial derivative with respect to the first dimension of the function's domain.
#' The next \eqn{n} elements of the vector is the gradient of the partial derivative of the second dimension of the function's domain.
#' The Hessian as a matrix, can be obtained by using [`as.matrix()`] with `ncol = n`.
#' @return A `Rcpp::XPtr` to a CppAD::ADFun object.
#' @export
pTapeHessian <- function(pfun, x, dynparam) {
    .Call('_scorecompdir_pTapeHessian', PACKAGE = 'scorecompdir', pfun, x, dynparam)
}

#' @export
pParameter <- function(pfun) {
    .Call('_scorecompdir_pParameter', PACKAGE = 'scorecompdir', pfun)
}

