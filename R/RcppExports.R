# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Generate manifold object
#' @param manifoldname The name of the manifold to transform to. Either 'sphere' or 'simplex'
#' @return An RCpp::XPtr object pointing to the C++ manifold object
#' @export
pmanifold <- function(manifoldname) {
    .Call('_cdabyppi_pmanifold', PACKAGE = 'cdabyppi', manifoldname)
}

#' @title Test a manifold object
#' @description A lightweight test of a manifold object.
#' Its main benefit is to force compilation of templated functions for the manifold,
#' and to print results to standard output.
#' @param pman An XPtr to a manifold object. Created by `pmanifold()`
#' @return An integer. 0 if the testable parts pass.
#' @export
testmanifold <- function(pman, u) {
    .Call('_cdabyppi_testmanifold', PACKAGE = 'cdabyppi', pman, u)
}

#' @title Apply to `toM` function of a manifold object
#' @description Apply the `toM` function of a manifold object.
#' @param pman An XPtr to a manifold object. Created by `pmanifold()`.
#' @param u A vector to be transformed to the manifold via `toM`.
#' @return A vector on the manifold.
#' @export
ptoM <- function(pman, u) {
    .Call('_cdabyppi_ptoM', PACKAGE = 'cdabyppi', pman, u)
}

#' @title The score matching objective calculator.
#' @param xbetain a concatenated vector of sqrt(x) and beta
#' @param n The dimension of x.
#' @param manifoldname The name of the manifold to transform to
#' @param weightname The name of the weight function to use
#' @param acut The constraint a_c in the weight function
#' @return An RCpp::XPtr object pointing to the ADFun
#' @export
ptapesmo <- function(u, theta, pll, pman, weightname, acut, verbose) {
    .Call('_cdabyppi_ptapesmo', PACKAGE = 'cdabyppi', u, theta, pll, pman, weightname, acut, verbose)
}

#' @title Tape of a log-likelihood calculation
#' @param p dimension of measurements
#' @param bd dimension of the parameter vector
#' @param llname name of the likelihood function
#' @return An RCpp::XPtr object pointing to the ADFun
#' @export
ptapell <- function(z, theta, llname, pman, fixedtheta, verbose) {
    .Call('_cdabyppi_ptapell', PACKAGE = 'cdabyppi', z, theta, llname, pman, fixedtheta, verbose)
}

#' @title Switch Dynamic and pure Independent values
#' @description Convert an ADFun so that the independent values become dynamic parameters
#' and the dynamic parameters become independent values
#' @param newvalue The value (in the sense after the switch has occured) at which to tape the ADFun
#' @param newdynparam The value of the now dynamic parameters at which to tape the ADFun
#' @return A pointer to an ADFun
#' @export
swapDynamic <- function(pfun, newvalue, newdynparam) {
    .Call('_cdabyppi_swapDynamic', PACKAGE = 'cdabyppi', pfun, newvalue, newdynparam)
}

#' @title The Jacobian of recorded function
#' @param pfun Rcpp::XPtr to an ADFun with dynamic parameters
#' @param u A vector in the simplex.
#' @param beta a vector of the dynamic parameters
#' @return The Jacobian of pfun
#' @export
pJacobian <- function(pfun, value, theta) {
    .Call('_cdabyppi_pJacobian', PACKAGE = 'cdabyppi', pfun, value, theta)
}

#' @title The value of a recorded function
#' @param pfun Rcpp::XPtr to an ADFun with dynamic parameters
#' @param value A vector in the domain of the taped function.
#' @param theta a vector of the dynamic parameters
#' @return The value of pfun
#' @export
pForward0 <- function(pfun, value, theta) {
    .Call('_cdabyppi_pForward0', PACKAGE = 'cdabyppi', pfun, value, theta)
}

#' @title The Hessian of recorded function
#' @param pfun Rcpp::XPtr to an ADFun with dynamic parameters
#' @param u A vector in the simplex.
#' @param beta a vector of the dynamic parameters
#' @return The Hessian of pfun
#' @export
pHessian <- function(pfun, value, theta) {
    .Call('_cdabyppi_pHessian', PACKAGE = 'cdabyppi', pfun, value, theta)
}

#' @title The value of a recorded function approximated by Taylor Expansion
#' @param pfun Rcpp::XPtr to an ADFun tape a tape with independent values that are the points to be differentiated with
#' @param value A vector in the domain of the taped function.
#' @param centre A vector in the domain of the taped function to approximate the value from.
#' @param theta a vector of the dynamic parameters
#' @param order The order of Taylor expansion to use.
#' @description Wrapper for the `taylorapprox` C++ function.
#' @return The approximate value of pfun
#' @export
pTaylorApprox <- function(pfun, value, centre, theta, order) {
    .Call('_cdabyppi_pTaylorApprox', PACKAGE = 'cdabyppi', pfun, value, centre, theta, order)
}

#' @title The approximate value of the gradient (wrt space 1) of recorded function
#' @param pfun Rcpp::XPtr to an ADFun tape a tape with dynamic parameters and independent parameters
#' @param value A vector in the domain of the taped function.
#' @param thetacentre A vector in the space of the dynamic parameters of the recorded function
#' this vector forms the centre of the Taylor approximation
#' @param theta a vector of the dynamic parameters
#' @param order The order of Taylor expansion to use.
#' @description Taylor expansion in the `theta` dimensions, to approximate the gradient wrt the `value` dimensions.
#' @return The approximate value of the gradient, with respect to theta, of pfun
#' @export
pTapeJacobianSwap <- function(pfun, value, theta) {
    .Call('_cdabyppi_pTapeJacobianSwap', PACKAGE = 'cdabyppi', pfun, value, theta)
}

#' @title The approximate value of the gradient (wrt space 1) of recorded function
#' @param pfun Rcpp::XPtr to an ADFun tape a tape with dynamic parameters and independent parameters
#' @param value A vector in the domain of the taped function.
#' @param thetacentre A vector in the space of the dynamic parameters of the recorded function
#' this vector forms the centre of the Taylor approximation
#' @param theta a vector of the dynamic parameters
#' @param order The order of Taylor expansion to use.
#' @description Taylor expansion in the `theta` dimensions, to approximate the gradient wrt the `value` dimensions.
#' @return The approximate value of the gradient, with respect to theta, of pfun
#' @export
pTapeHessianSwap <- function(pfun, value, theta) {
    .Call('_cdabyppi_pTapeHessianSwap', PACKAGE = 'cdabyppi', pfun, value, theta)
}

