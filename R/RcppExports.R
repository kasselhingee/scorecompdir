# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Switch Dynamic and Independent Values of a Tape
#' @family tape builders
#' @description Convert an ADFun so that the independent values become dynamic parameters
#' and the dynamic parameters become independent values
#' @param pfun An Rcpp::XPtr to an ADFun object (i.e. a tape of a function)
#' @param newvalue The independent value (in the sense after the switch has occurred) at which to tape the ADFun
#' @param newdynparam The value of the dynamic parameters (after the switch) at which to tape the ADFun
#' @return A pointer to an ADFun
#' @export
swapDynamic <- function(pfun, newvalue, newdynparam) {
    .Call('_scorecompdir_swapDynamic', PACKAGE = 'scorecompdir', pfun, newvalue, newdynparam)
}

#' @title Evaluate the Jacobian of a tape
#' @param pfun An Rcpp::XPtr to an ADFun object (i.e. a tape of a function)
#' @param value A vector in the domain of the taped function.
#' @param dynparam a vector of the dynamic parameters. If `pfun` has no dynamic parameters then set `dynparam = vector(mode = "numeric")`.
#' @return The Jacobian of pfun
#' @export
pJacobian <- function(pfun, value, dynparam) {
    .Call('_scorecompdir_pJacobian', PACKAGE = 'scorecompdir', pfun, value, dynparam)
}

#' @title Evaluate a CppAD tape
#' @param pfun Rcpp::XPtr to an ADFun with dynamic parameters
#' @param x A vector in the domain of the taped function.
#' @param dynparam a vector of the dynamic parameters.
#' @return The value of `pfun` evaluated at `x` with parameters `dynparam`.
#' @export
pForward0 <- function(pfun, x, dynparam) {
    .Call('_scorecompdir_pForward0', PACKAGE = 'scorecompdir', pfun, x, dynparam)
}

#' @title The Hessian of recorded function.
#' @param pfun An Rcpp::XPtr to an ADFun object (i.e. a tape of a function)
#' @param value A vector in the domain of the taped function.
#' @param dynparam a vector of the dynamic parameters. If `pfun` has no dynamic parameters then set `dynparam = vector(mode = "numeric")`.
#' @export
#' @return The Hessian of pfun as a vector.
pHessian <- function(pfun, value, dynparam) {
    .Call('_scorecompdir_pHessian', PACKAGE = 'scorecompdir', pfun, value, dynparam)
}

#' @title Tape the Jacobian of CppAD Tape
#' @family tape builders
#' @param pfun Rcpp::XPtr to an ADFun tape a tape with dynamic parameters and independent parameters
#' @param x A vector in the domain of the taped function.
#' @param dynparam a vector of the dynamic parameters
#' @description Creates a tape of the Jacobian of function taped by CppAD.
#' When the function returns a real value (as is the case for densities and the score matching objective) the Jacobian is equivalent to the gradient.
#' The `x` vector is used as the value to conduct the taping.
#' @details
#' When the returned tape is evaluated (via say [`pForward0()`], the resultant vector contains the Jacobian in long format (see <https://cppad.readthedocs.io/en/latest/Jacobian.html>).
#' Suppose the function represented by `pfun` maps from \eqn{n}-dimensional space to \eqn{m}-dimensional space, then
#' the first \eqn{n} elements of vector is the gradient of the first component of function output.
#' The next \eqn{n} elements of the vector is the gradient of the second component of the function output.
#' The Jacobian as a matrix, could then be obtained by [`as.matrix()`] with `byrow = TRUE` and `ncol = n`.
#' @return A `Rcpp::XPtr` to a CppAD::ADFun object.
#' @export
pTapeJacobian <- function(pfun, x, dynparam) {
    .Call('_scorecompdir_pTapeJacobian', PACKAGE = 'scorecompdir', pfun, x, dynparam)
}

#' @title Tape the Hessian of a CppAD Tape
#' @family tape builders
#' @inheritParams pTapeJacobian
#' @description Creates a tape of the Hessian of a function taped by CppAD.
#' The taped function represented by `pfun` must be scalar-valued (i.e. a vector of length 1).
#' The `x` vector and `dynparam` are used as the values to conduct the taping.
#' @details
#' When the returned tape is evaluated (via say [`pForward0()`], the resultant vector contains the Hessian in long format (see <https://cppad.readthedocs.io/en/latest/Hessian.html>).
#' Suppose the function represented by `pfun` maps from \eqn{n}-dimensional space to \eqn{1}-dimensional space, then
#' the first \eqn{n} elements of the vector is the gradient of the partial derivative with respect to the first dimension of the function's domain.
#' The next \eqn{n} elements of the vector is the gradient of the partial derivative of the second dimension of the function's domain.
#' The Hessian as a matrix, can be obtained by using [`as.matrix()`] with `ncol = n`.
#' @return A `Rcpp::XPtr` to a CppAD::ADFun object.
#' @export
pTapeHessian <- function(pfun, x, dynparam) {
    .Call('_scorecompdir_pTapeHessian', PACKAGE = 'scorecompdir', pfun, x, dynparam)
}

#' @title Indicate Constant Components of Range
#' @description Use `CppAD`'s `Parameter()` function for `ADFun` objects to see if the returned values of a tape are constant with respect to the independent values.
#' @param pfun A CppAD tape.
#' @return A vector logical values. `TRUE` indicates that element of the tape result is constant.
#' @details The `CppAD` function [`Parameter(i)`](https://cppad.readthedocs.io/en/latest/fun_property.html#parameter) returns `TRUE` when the `i`th component of the range does not depend on the independent value
#' (the `i`th component may still depend on the value of the dynamic parameters - see <https://cppad.readthedocs.io/en/latest/glossary.html#dynamic> ).
#' @export
pParameter <- function(pfun) {
    .Call('_scorecompdir_pParameter', PACKAGE = 'scorecompdir', pfun)
}

#' @title Tape the Gradient Offset of a Quadratic CppAD Tape
#' @family tape builders
#' @inheritParams pTapeJacobian
#' @description A quadratic function can be written as
#' \deqn{f(x;\theta) = \frac{1}{2} x^T W(\theta) x + b(\theta)^Tx + c.}
#' The function `pTapeGradOffset` creates a tape of \eqn{b(\theta)} where \eqn{\theta} is the independent variable.
#' @param pfun A quadratic CppAD Tape. Test for quadratic form using [`testquadratictape()`].
#' @details
#' The gradient of \eqn{f(x; \theta)} with respect to \eqn{\theta} is
#' \deqn{\Delta f(x; \theta) = \frac{1}{2}(W(\theta) + W(\theta)^T)\theta + b(\theta),}
#' and the Hessian is 
#' \deqn{H f(x; \theta) = \frac{1}{2}(W(\theta) + W(\theta)^T),}
#' which does not depend on \eqn{x}.
#' The gradient of the function can be rewritten as
#' \deqn{\Delta f(x;\theta) = H f(x; \theta) x + b(\theta)^T x.}
#' The tape calculates \eqn{b(\theta)} as
#'  \deqn{b(\theta) = \Delta f(x;\theta) - H f(x; \theta) x},
#' which does not depend on \eqn{x}.
#' In `pTapeGradOffset()` the `x` provided as an argument is used as the template for calculating \eqn{b(\theta)}.
#' The `x` vector and `dynparam` are used as the values to conduct the taping.
#' @return A `Rcpp::XPtr` to a CppAD::ADFun object. The independent argument to the function are the dynamic parameters of `pfun`.
#' @export
pTapeGradOffset <- function(pfun, x, dynparam) {
    .Call('_scorecompdir_pTapeGradOffset', PACKAGE = 'scorecompdir', pfun, x, dynparam)
}

#' @title Tape the log of Jacobian determinant of a CppAD Tape
#' @family tape builders
#' @param pfun Rcpp::XPtr to an ADFun tape a tape with dynamic parameters and independent parameters
#' @param x A vector in the domain of the taped function.
#' @param dynparam a vector of the dynamic parameters
#' @description Creates a tape of the log of the Jacobian determinant of a function taped by CppAD.
#' The `x` vector is used as the value to conduct the taping.
#' @return A `Rcpp::XPtr` to a CppAD::ADFun object.
#' @export
ptapelogdetJ <- function(pfun, x, dynparam) {
    .Call('_scorecompdir_ptapelogdetJ', PACKAGE = 'scorecompdir', pfun, x, dynparam)
}

#' @noRd
#' @title Generate manifold with transformation object
#' @param manifoldname The name of the manifold to transform to. Either 'sphere' or 'simplex'
#' @return An RCpp::XPtr object pointing to the C++ manifold object
#' @details
#'  + "sphere" for square-root transformation from the simplex to the positive orthant of the sphere
#'  + "simplex" for the simplex without any transformation.
#'  + "Ralr" for the additive log-ratio transformation from the simplex to Euclidean space, using the final component of vectors in the denominator of the ratio.
#'  + "Snative" for the sphere without any transformation
pmanifold <- function(manifoldname) {
    .Call('_scorecompdir_pmanifold', PACKAGE = 'scorecompdir', manifoldname)
}

printgraph <- function(pfun) {
    invisible(.Call('_scorecompdir_printgraph', PACKAGE = 'scorecompdir', pfun))
}

#' @noRd
#' @title Tape of a log-likelihood calculation
#' @param p dimension of measurements
#' @param bd dimension of the parameter vector
#' @param llname name of the likelihood function
#' @return An RCpp::XPtr object pointing to the ADFun
ptapell <- function(z_ad, theta_ad, llname, pman, fixedtheta, verbose) {
    .Call('_scorecompdir_ptapell', PACKAGE = 'scorecompdir', z_ad, theta_ad, llname, pman, fixedtheta, verbose)
}

#' @noRd
#' @title The score matching objective calculator.
#' @param xbetain a concatenated vector of sqrt(x) and beta
#' @param n The dimension of x.
#' @param manifoldname The name of the manifold to transform to
#' @param weightname The name of the weight function to use
#' @param acut The constraint a_c in the weight function
#' @return An RCpp::XPtr object pointing to the ADFun
ptapesmo <- function(u_ad, theta_ad, pll, pman, weightname, acut, verbose) {
    .Call('_scorecompdir_ptapesmo', PACKAGE = 'scorecompdir', u_ad, theta_ad, pll, pman, weightname, acut, verbose)
}

#' @noRd
#' @title Apply to `toM` function of a manifold object
#' @description Apply the `toM` function of a manifold object.
#' @param pman An Rcpp::XPtr to a manifold object. Created by [`manifoldtransform()`].
#' @param u A vector to be transformed to the manifold via `toM`.
#' @return A vector on the manifold.
ptoM <- function(pman, u_ad) {
    .Call('_scorecompdir_ptoM', PACKAGE = 'scorecompdir', pman, u_ad)
}

#' @title The value of a recorded function approximated by Taylor expansion
#' @param pfun Rcpp::XPtr to an ADFun tape a tape with independent values that are the points to be differentiated with
#' @param u A vector in the domain of the taped function.
#' @param centre A vector in the domain of the taped function to approximate the value at `u` from.
#' @param dynparam a vector of the dynamic parameters
#' @param order The order of Taylor expansion to use.
#' @description Approximates the value of a `CppAD` tape at `u` using a Taylor approximation at `centre`. The dynamic parameters of the tape are set by `dynparam`.
#' @return The approximate value of pfun
#' @export
pTaylorApprox <- function(pfun, u, centre, dynparam, order) {
    .Call('_scorecompdir_pTaylorApprox', PACKAGE = 'scorecompdir', pfun, u, centre, dynparam, order)
}

ptapefromM <- function(z, pman) {
    .Call('_scorecompdir_ptapefromM', PACKAGE = 'scorecompdir', z, pman)
}

