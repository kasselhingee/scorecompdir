% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ppi_smvalues.R
\name{ppi_smvalues}
\alias{ppi_smvalues}
\title{Compute score matching discrepancy value, gradient, and Hessian for a PPI Model}
\usage{
ppi_smvalues(
  Y,
  paramvec = NULL,
  evalparam,
  trans,
  method = "closed",
  w = rep(1, nrow(Y)),
  bdryw = "ones",
  acut = NULL,
  bdrythreshold = 1e-10,
  shiftsize = bdrythreshold,
  approxorder = 10,
  average = TRUE
)
}
\arguments{
\item{Y}{A matrix of measurements. Each row is a measurement, each component is a dimension of the measurement.}

\item{paramvec}{Optionally a vector of the PPI models parameters. Non-NA values are fixed, NA-valued elements are estimated. Generate \code{paramvec} easily using \code{\link[=ppi_paramvec]{ppi_paramvec()}}.  If \code{NULL} then all elements of \eqn{A_L}, \eqn{b_L} and \eqn{\beta} are estimated.}

\item{evalparam}{The parameter set to evaluate the score matching values.
This is different to \code{paramvec}, which \emph{fixes} parameters and constrains the estimation.
All elements of \code{evalparam} must be non-NA, and if there are any parameter fixed by \code{paramvec} then \code{evalparam} must match them (and it will warn if not).}

\item{trans}{The name of the transformation: "alr" (additive log ratio), "sqrt" or "none".}

\item{method}{"hardcoded" uses the hardcoded estimators by JS. "closed" uses \code{CppAD} to solve in closed form the a quadratic score matching discrepancy using \code{\link[=cppad_closed]{cppad_closed()}}. "iterative" uses \code{\link[=cppad_search]{cppad_search()}} (which uses \code{CppAD} and \code{\link[optimx:Rcgmin]{optimx::Rcgmin()}}) to iteratively find the minimum of the weighted Hyv\"arinen divergence.}

\item{w}{Weights for each observation, if different observations have different importance. Used by \code{\link[=Windham]{Windham()}} and \code{\link[=ppi_robust]{ppi_robust()}} for robust estimation.}

\item{bdryw}{The boundary weight function for down weighting measurements as they approach the manifold boundary. Either "ones", "minsq" or "prodsq". See details.}

\item{acut}{The threshold \eqn{a_c} in \code{bdryw} to avoid over-weighting measurements interior to the simplex}

\item{bdrythreshold}{\code{iterative} or \code{closed} methods only. For measurements close to the boundary of the simplex Taylor approximation is applied. See \code{\link[=simplex_isboundary]{simplex_isboundary()}}.}

\item{shiftsize}{\code{iterative} or \code{closed} methods only. For Taylor approximation, approximation centres are chosen based on \code{shiftsize}. See \code{\link[=simplex_boundaryshift]{simplex_boundaryshift()}}.}

\item{approxorder}{\code{iterative} or \code{closed} methods only. Order of the Taylor approximation for measurements on the boundary of the simplex.}

\item{average}{If TRUE return the (weighted average) of the measurements, otherwise return the values for each measurement.}
}
\value{
A list of
\itemize{
\item \code{obj} the score matching discrepancy value
\item \code{grad} the gradient of the score matching discrepancy
\item \code{hess} the Hessian of the score matching discrepancy
\item \code{offset} gradient offset (see \code{\link[=quadratictape_parts]{quadratictape_parts()}})
}
}
\description{
Using similar arguments to \code{\link[=ppi]{ppi()}}, compute values related to score matching. See \code{\link[=smvalues_tape]{smvalues_tape()}}. The gradient offset is also computed (see \code{\link[=quadratictape_parts]{quadratictape_parts()}}.
}
\seealso{
Other PPI model tools: 
\code{\link{dppi}()},
\code{\link{ppi_parammats}()},
\code{\link{ppi_paramvec}()},
\code{\link{ppi_robust_alrgengamma}()},
\code{\link{ppi_robust}()},
\code{\link{ppi_toAstar}()},
\code{\link{ppi}()},
\code{\link{rppi}()}
}
\concept{PPI model tools}
