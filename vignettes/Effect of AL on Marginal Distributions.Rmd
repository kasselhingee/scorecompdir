---
title: "Effect of PPI's AL on Marginal Distributions"
author: "Kassel Hingee"
date: "22/06/2022"
output: html_document
---

The effect of the matrix $A_L$ on marginal distributions can be large, and override the Dirichlet component of the density. A large `maxden` required for `rhybrid()` would be symptomatic of peaks near zero occurring at odds to the Dirichlet component of the density.

To the credit of the sandwich method for standard errors - the estimates have thus far mostly been within 3 standard errors of the true values (the standard errors have been huge).

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
library(cdabyppi)
library(ggplot2)
library(dplyr)
library(tidyr)
library(ggtern)
library(cubature) #for high quality numeric integration
```

## An example for p=3
### A
```{r pis3_A, echo = FALSE}
  set.seed(1273)
  p = 3
  ALs <- exp(rsymmetricmatrix(p-1, -4, 4))
  bL <- rep(0, p-1)
  beta <- c(-0.7, -0.3, 0)
  # set.seed(1345) #this seed leads to samples with that give reasonable estimates
  set.seed(1111) #this seed leads to some ginormous elements for the second diagonal element of ALs
  prop <- rhybrid(1000, p, beta, ALs, bL, 4)$samp
  print(ALs)
  
  prop %>% as_tibble() %>% tidyr::pivot_longer(everything()) %>% ggplot() + facet_wrap(vars(name)) + geom_freqpoly(aes(x=value))
```

### B
A different $A_L$:
```{r pis3_B, echo = FALSE}
  set.seed(12735)
  p = 3
  ALs <- exp(rsymmetricmatrix(p-1, -4, 4))
  bL <- rep(0, p-1)
  beta <- c(-0.7, -0.3, 0)
  # set.seed(1345) #this seed leads to samples with that give reasonable estimates
  set.seed(1111) #this seed leads to some ginormous elements for the second diagonal element of ALs
  prop <- rhybrid(1000, p, beta, ALs, bL, 20)$samp
  print(ALs)
  
  prop %>% as_tibble() %>% tidyr::pivot_longer(everything()) %>% ggplot() + facet_wrap(vars(name)) + geom_freqpoly(aes(x=value))
```

Both the concentration near V3=zero and the concentration near V2=1 is surprising. The Dirichlet component of the model should force a concentration of points near V1=0, V2=0 and V3=1.

```{r Bplots}
xval <- seq(0,1, by = 0.001)
crds <- expand.grid(x = xval, y = xval)
crds$z <- 1 - rowSums(crds)
crds <- crds[crds$z>=0, ]
crds$uAu <- t(qldppi(as.matrix(crds), beta0 = rep(0, p), ALs = ALs, bL = bL))
crds$qldval <- qldppi(as.matrix(crds[, 1:3]), beta0 = beta, ALs = ALs, bL = bL)
crds$betalogu <- qldppi(as.matrix(crds[, 1:3]), beta0 = beta, ALs = matrix(0, p-1,p-1), bL = bL)

crds %>%
  as_tibble() %>%
  tidyr::pivot_longer(cols = c("uAu", "betalogu", "qldval")) %>%
  ggplot() +
  facet_grid(cols = vars(name)) +
  geom_tile(aes(x = x, y = y, fill = value)) +
  scale_fill_distiller(palette = "PuBuGn")#, trans = "log10")#, labels = scales::label_number())
  # scale_fill_viridis_c(trans = "log10", labels = scales::label_number(), option = "D")


xval <- seq(0, 1E-14, by = 1E-15)
crds <- expand.grid(x = 1-xval - 0.01, y = xval)
crds$z <- 1 - rowSums(crds)
crds <- crds[crds$z>=0, ]
crds$uAu <- t(qldppi(as.matrix(crds), beta0 = rep(0, p), ALs = ALs, bL = bL))
crds$qldval <- qldppi(as.matrix(crds[, 1:3]), beta0 = beta, ALs = ALs, bL = bL)
crds$betalogu <- qldppi(as.matrix(crds[, 1:3]), beta0 = beta, ALs = matrix(0, p-1,p-1), bL = bL)

crds %>%
  as_tibble() %>%
  tidyr::pivot_longer(cols = c("uAu", "betalogu", "qldval")) %>%
  dplyr::filter(name != "uAu") %>%
  ggplot() +
  facet_grid(cols = vars(name)) +
  geom_tile(aes(x = x, y = y, fill = value)) +
  scale_fill_distiller(palette = "YlGnBu")#, trans = "log10")#, labels =
```

The Dirichlet component's density spike at x=0 is found by the simulator. The density spike at y=0 is there but it is much narrower than the x=0 spike. This narrowness might mean that the spike at y=0 contains little probability mass, which could explain how `rhybrid()` is not showing the spike.

Below lets use numeric quadrature to see if the spike contains very little probability mass.

```{r integrateregions}
integrand <- function(arg){ #arg is a matrix with 2 rows
  crds <- t(arg)
  crds <- cbind(crds, 1 - rowSums(crds))
  crds[crds[,3] <= 0, 3] <- NA #remove the boundary too - because the qldppi evaluates to infinity on boundary
  crds[crds[,3] >= 1, 3] <- NA
  crds[crds[,1] <= 0, 1] <- NA
  crds[crds[,1] >= 1, 1] <- NA
  crds[crds[,2] <= 0, 2] <- NA
  crds[crds[,2] >= 1, 2] <- NA
  vals <- qldppi(as.matrix(crds[, 1:3]), beta0 = beta, ALs = ALs, bL = bL)
  vals <- as.vector(vals)
  # vals <- rep(1, nrow(crds)) #for constant integration
  vals[rowSums(is.na(crds)) > 0] <- 0
  out <- as.matrix(vals, nrow = 1)
  return(out)
}

distfromo <- 1E-2
# following total volume integration is just for checking
# volumetotal <- cubature::cubintegrate(f = integrand,
#                    lower = c(0, 0),
#                    upper = c(1,1),
#                    method = "hcubature",
#                    nVec = 1024)
integrals <- list()
integrals[["z~1"]] <- cubature::cubintegrate(f = integrand, lower = c(0, 0), upper = c(distfromo,distfromo), method = "hcubature", nVec = 1024)
integrals[["other x~0"]] <- cubature::cubintegrate(f = integrand, lower = c(0, distfromo), upper = c(distfromo,1), method = "hcubature", nVec = 1024)
integrals[["other y~0"]] <- cubature::cubintegrate(f = integrand, lower = c(distfromo, 0), upper = c(1,distfromo), method = "hcubature", nVec = 1024)
integrals[["x>0,y>0"]] <- cubature::cubintegrate(f = integrand, lower = c(distfromo, distfromo), upper = c(1,1), method = "hcubature", nVec = 1024)

integrals$centralrect <- 
  cubature::cubintegrate(f = integrand, lower = c(distfromo, 0.5), upper = c(1,0.5+distfromo), method = "hcubature", nVec = 1024)
integrals$nearlyedgerect <- 
  cubature::cubintegrate(f = integrand, lower = c(distfromo, distfromo), upper = c(1,distfromo+distfromo), method = "hcubature", nVec = 1024)
volumes <- unlist(lapply(integrals, "[[", 'integral'))
totalvol <- sum(volumes[["other y~0"]] + volumes[["z~1"]] + volumes[["other x~0"]] + volumes[["x>0,y>0"]])
stopifnot(abs(totalvol - 2.294102) < 1E-5)
format(volumes/totalvol, digits = 3)
sprintf("All y~0 volume is %0.3f", (volumes[["other y~0"]] + volumes[["z~1"]]) / totalvol)
```

The mass with y<=`r distfromo` is about the same as a similar-sized area in the centre of the simplex. For 1000 points, on average only 10 will be in the boundary region, and this will appear to have a similar amount to same-sized regions interior to the simplex.

```{r integrateregions_tinydistfromo}
distfromo <- 1E-3
integrals <- list()
integrals[["z~1"]] <- cubature::cubintegrate(f = integrand, lower = c(0, 0), upper = c(distfromo,distfromo), method = "hcubature", nVec = 1024)
integrals[["other x~0"]] <- cubature::cubintegrate(f = integrand, lower = c(0, distfromo), upper = c(distfromo,1), method = "hcubature", nVec = 1024)
integrals[["other y~0"]] <- cubature::cubintegrate(f = integrand, lower = c(distfromo, 0), upper = c(1,distfromo), method = "hcubature", nVec = 1024)
integrals[["x>0,y>0"]] <- cubature::cubintegrate(f = integrand, lower = c(distfromo, distfromo), upper = c(1,1), method = "hcubature", nVec = 1024)

integrals$centralrect <- 
  cubature::cubintegrate(f = integrand, lower = c(distfromo, 0.5), upper = c(1,0.5+distfromo), method = "hcubature", nVec = 1024)
integrals$nearlyedgerect <- 
  cubature::cubintegrate(f = integrand, lower = c(distfromo, distfromo), upper = c(1,distfromo+distfromo), method = "hcubature", nVec = 1024)
volumes <- unlist(lapply(integrals, "[[", 'integral'))
totalvol <- sum(volumes[["other y~0"]] + volumes[["z~1"]] + volumes[["other x~0"]] + volumes[["x>0,y>0"]])
format(volumes/totalvol, digits = 3)
sprintf("All y~0 volume is %0.4f", (volumes[["other y~0"]] + volumes[["z~1"]]) / totalvol)
```

The mass with y<=`r distfromo` is about the same as a similar-sized area in the centre of the simplex. For 1000 points, on average only 1 will be in the boundary region, and this will appear to have a similar amount to same-sized regions interior to the simplex. 


```{r integrateregions_tiniertinydistfromo}
distfromo <- 1E-5
integrals <- list()
integrals[["z~1"]] <- cubature::cubintegrate(f = integrand, lower = c(0, 0), upper = c(distfromo,distfromo), method = "hcubature", nVec = 1024)
integrals[["other x~0"]] <- cubature::cubintegrate(f = integrand, lower = c(0, distfromo), upper = c(distfromo,1), method = "hcubature", nVec = 1024)
integrals[["other y~0"]] <- cubature::cubintegrate(f = integrand, lower = c(distfromo, 0), upper = c(1,distfromo), method = "hcubature", nVec = 1024)
integrals[["x>0,y>0"]] <- cubature::cubintegrate(f = integrand, lower = c(distfromo, distfromo), upper = c(1,1), method = "hcubature", nVec = 1024)

integrals$centralrect <- 
  cubature::cubintegrate(f = integrand, lower = c(distfromo, 0.5), upper = c(1,0.5+distfromo), method = "hcubature", nVec = 1024)
integrals$nearlyedgerect <- 
  cubature::cubintegrate(f = integrand, lower = c(distfromo, distfromo), upper = c(1,distfromo+distfromo), method = "hcubature", nVec = 1024)
volumes <- unlist(lapply(integrals, "[[", 'integral'))
totalvol <- sum(volumes[["other y~0"]] + volumes[["z~1"]] + volumes[["other x~0"]] + volumes[["x>0,y>0"]])
format(volumes/totalvol, digits = 3)
sprintf("All y~0 volume is %0.4g", (volumes[["other y~0"]] + volumes[["z~1"]]) / totalvol)
```

The mass with y<=`r distfromo` is 30% larger than the mass of a similar sized rectangle in the interior of the simplex. If one simulated enough, one would expect to see more points in the boundary rectangle than the interior (or nearly boundary) rectangle. However, the mass of 2E-5 is so small that on average a sample of 50000 points will have only 1 point in the boundary region.

## Conclusion
The second $A_L$ is such that the concentration of mass at $y=0$ is so narrow (and containting little probability mass) that well over 50000 points would be needed to detect it.

Is there a way I can reliably anticipate when this will happen from the value of $A_L$, without simulation?

*(currently I've got a quick warning for when `maxden` goes above `10` in `rhybrid()`)*
